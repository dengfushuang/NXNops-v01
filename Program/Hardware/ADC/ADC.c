/******************************************************************************

                 版权所有 (C), 2001-2013, 桂林恒毅金宇通信技术有限公司

******************************************************************************
 文 件 名   : ADC.c
 版 本 号   : 初稿
 作    者   :
 生成日期   : 2013年5月10日
 最近修改   :
 功能描述   :
 函数列表   :
             adcdeal
             ADC_int
             addo
             optics_collec
******************************************************************************/

#include "math.h"
#include "ADC.h"
#include "LPC177x_8x.h"
#include "uart0.h"

#define CHTEMP  3
#define minadc  40   	              //minadc=20;太低了，应该考虑高一些（30~50），提高抗干扰能力。
#define maxadc  1000

uint8 hardware_way[CHANNEL_NUM*2];  //真实的硬件档位
float power[CHANNEL_NUM*2];
float power_warn[CHANNEL_NUM*2];
float power_count[CHANNEL_NUM*2];
uint8_t warn[CHANNEL_NUM*2];			  //告警状态：0不告警    1告警


/*****************************************************************************
**函 数 名: ADC_int
**功能描述: ADC 初始化
**输入参数: rate ADC的换率应
**输出参数: 无
**返 回 值: LPC_ADC->DR
*****************************************************************************/
void ADC_int(uint32 rate)
{
    //使能以ADC控制器电源
    LPC_SC->PCONP |= (1U << 12);

    // Enable  Ethernet Pins.
    LPC_IOCON->P0_23 = 0x01;     //ADC0[0]
    LPC_IOCON->P0_24 = 0x01;     //ADC0[1]
    LPC_IOCON->P0_25 = 0x01;     //ADC0[2]
    LPC_IOCON->P0_26 = 0x01;     //ADC0[3]
    LPC_IOCON->P1_30 = 0x03;     //ADC0[4]
    LPC_IOCON->P1_31 = 0x03;     //ADC0[5]
    LPC_IOCON->P0_12 = 0x03;     //ADC0[6]
    LPC_IOCON->P0_13 = 0x03;     //ADC0[7]

    LPC_GPIO0->DIR |= (1<<17);
		LPC_GPIO0->DIR |= (1<<18);
		LPC_GPIO0->DIR |= (1<<19);
		LPC_GPIO0->DIR |= (1<<20);
		LPC_GPIO0->DIR |= (1<<21);
		LPC_GPIO0->DIR |= (1<<22);
	
    //进行ADC模块设置，其中x<<n表示第n位设置为x(若x超过一位，则向高位顺延)
    LPC_ADC->CR = 0;
    LPC_ADC->CR = (1 << 0)              |     // SEL = 0 ，选择通道1
                  ((PeripheralClock / 1000000 - 1) << 8) |     // CLKDIV = Fpclk / 1000000 - 1 ，即转换时钟为1MHz
                  (0 << 16)                    |     // BURST = 0 ，软件控制转换操作
                  (0 << 17)                    |     // CLKS = 0 ，使用11clock转换
                  (1 << 21)                    |     // PDN = 1 ， 正常工作模式(非掉电转换模式)
                  (0 << 22)                    |     // TEST1:0 = 00 ，正常工作模式(非测试模式)
                  (1 << 24)                    |     // START = 1 ，启动ADC转换
                  (0 << 27);                         // EDGE = 0 (CAP/MAT引脚下降沿触发ADC转换)

    while ((LPC_ADC->GDR & 0x80000000) == 0); // 等待转换结束
}


/*********************************************************************************************************
** 函数名称: void addo(uint8 ch)
** 功能描述: adc转换
** 输　入: AD号数
** 输　出: ADC结果
** 运算时间 :
********************************************************************************************************/
uint32 addo(uint8 ch)
{
    uint32 ADC_Data;

	  switch(ch)
		{
			  case 0:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x01|(1 << 24);  break;
				case 1:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x02|(1 << 24);  break;
//				case 2:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x04|(1 << 24);  break;
//				case 3:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x08|(1 << 24);  break;
//				case 4:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x10|(1 << 24);  break;
//				case 5:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x20|(1 << 24);  break;
//				case 6:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x40|(1 << 24);  break;
//				case 7:  LPC_ADC->CR = (LPC_ADC->CR&0x00FFFF00)|0x80|(1 << 24);  break;
			  default:  break;
		}

    while ((LPC_ADC->GDR & 0x80000000) == 0);            // 等待转换结束
    LPC_ADC->CR = LPC_ADC->CR | (1 << 24);               // 再次启运转换
    while ((LPC_ADC->GDR & 0x80000000) == 0);            // 等待转换结束

    ADC_Data = LPC_ADC->GDR;                             // 读取ADC结果
    ADC_Data = (ADC_Data >> 6) & 0x3FF;                  // 提取AD转换值 (bit4~bit15 为12位的ADC值)，现在只取10位的ADC值

    return ADC_Data;
}


/*****************************************************************************
**函 数 名: adcdeal
**功能描述:
**输入参数: uint8 RTnum
             uint32 way_temp
             float  adc
**输出参数: 无
**返 回 值:
**调用函数:
**被调函数:
*****************************************************************************/
void adcdeal(uint8 RTnum,uint32 way, float adc)
{
    if(adc > 800)
    {
        if(way > 0)
        {
            way = way - 1;
            adc = adc / 10;
        }
        else
        {
            way = way;
            adc = 800;
        }
    }
    else if(adc < 80)
    {
        if(way < 7)
        {
            way = way + 1;
            adc = adc * 10;
        }
        else
        {
            way = way;  	   //解决了死机问题
            adc = 80;
        }
    }
    //*****************************防止超过10倍*****************************
    if(adc > 800)
    {
        if(way > 0)
        {
            way = way - 1;
            adc = adc / 10;
        }
        else
        {
            way = way;
            adc = 800;
        }
    }
    else if(adc < 80)
    {
        if(way < 7)
        {
            way = way + 1;
            adc = adc * 10;
        }
        else
        {
            way = way;  	 //解决了死机问题
            adc = 80;
        }
    }

    if(way >= CHTEMP)      //负值
    {
        adc = 800.0 / adc;
        adc = 10 * log10(adc);
        adc = adc + 10 * (way - CHTEMP);
        adc = (-1) * adc;
    }
    else                 //正值
    {
        adc = adc / 80.0;
        adc = 10 * log10(adc);
        adc = adc + 10 * ((CHTEMP - 1) - way);
    }

    //adc += ((float)EPROM.ADC_just[RTnum][EPROM.wavelength[RTnum]])/10.0; //加上校准补偿系数

    if(adc > 30.0)      adc = 30.0;
    if(adc < -50.0)     adc = -50.0;
		
    power[RTnum] = adc;
    if(power[RTnum] <= EPROM.q_power[RTnum])
    {
			  power_warn[RTnum] = power[RTnum];
        warn[RTnum] = 1;
    }
    else
    {
        warn[RTnum] = 0;
    }
}


/*****************************************************************************
**函 数 名: CHANNEL
**功能描述:
**输入参数: uint8 RTnum
            uint8 way_temp
**输出参数: 无
**返 回 值:
*****************************************************************************/
void CHANNEL(uint8 RTnum, uint8 way_temp)
{
    switch ( RTnum )
    {
				case 0 :
						CHANNEL_PIN0(way_temp);
						break;
				case 1 :
						CHANNEL_PIN1(way_temp);
						break;
//				case 2 :
//						CHANNEL_PIN2(way_temp);
//						break;
//				case 3 :
//						CHANNEL_PIN3(way_temp);
//						break;
//				case 4 :
//						CHANNEL_PIN4(way_temp);
//						break;
//				case 5 :
//						CHANNEL_PIN5(way_temp);
//						break;
//				case 6 :
//						CHANNEL_PIN6(way_temp);
//						break;
//				case 7 :
//						CHANNEL_PIN7(way_temp);
//						break;
				default:
						break;
    }
}


/*****************************************************************************
 函 数 名  : optics_collect
 功能描述  : 控制换挡电路，采集光信号转换成光功率值
 输入参数  : uint8 RTnum
             uint8 way
 输出参数  : 无
 返 回 值  :
*****************************************************************************/
void optics_collect(uint8_t RTnum , uint8_t way_temp)
{
    uint16_t ADC_Data;
    float  ADC_just_temp;
    OS_CPU_SR  cpu_sr;

ADC_STAR:
    ADC_Data = (uint16_t)addo(RTnum);
    if (ADC_Data < minadc)                  //AD转换值小于20，换通道
    {
        if (way_temp < 7)
        {
            way_temp ++;

            OS_ENTER_CRITICAL();
            CHANNEL(RTnum, way_temp);       //设定到1通道
            OS_EXIT_CRITICAL();	

            OSTimeDly(10);
            goto ADC_STAR;
        }
    }
    else if (ADC_Data > maxadc)             //AD转换值大于1000，换通道
    {
        if (way_temp > 0)
        {
            way_temp --;

            OS_ENTER_CRITICAL();
            CHANNEL(RTnum, way_temp);       //设定到1通道
            OS_EXIT_CRITICAL();

            OSTimeDly(10);                  //换挡延时时间，与探测器和电路有关，会影响到切换时间。取合适为宜。
            goto ADC_STAR;
        }
    }

    ADC_just_temp = (float)ADC_Data;
    //加上校准补偿系数
//    if (EPROM.ADC_just[RTnum][EPROM.wavelength[RTnum]] > 0)
//    {
//        for (i = 0 ; i < EPROM.ADC_just[RTnum][EPROM.wavelength[RTnum]] ; i++)
//        {
//            ADC_just_temp = ADC_just_temp * 1.023293;
//        }
//    }
//    else if (EPROM.ADC_just[RTnum][EPROM.wavelength[RTnum]] < 0)
//    {
//        for (i = 0 ; i < (~(EPROM.ADC_just[RTnum][EPROM.wavelength[RTnum]] - 1)) ; i++)
//        {
//            ADC_just_temp = ADC_just_temp * 0.977237;
//        }
//    }

    adcdeal(RTnum, way_temp, ADC_just_temp);
    hardware_way[RTnum] = way_temp;   //再把真实的档位放到全局变量 hardware_way
}

