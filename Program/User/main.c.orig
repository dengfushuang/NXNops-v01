/******************************************************************************

                  版权所有 (C), 2001-2013, 桂林恒毅金宇通信技术有限公司

 ******************************************************************************
  文 件 名   : main.c
  版 本 号   : 初稿
  作    者   :
  生成日期   : 2013年6月19日
  最近修改   :
  功能描述   :
******************************************************************************/
#include "config.h"
#include "main.h"
#include "stdlib.h"
#include "math.h"
#include "lcd16032.h"
#include "delay.h"

#include "includes.h"
#include "uart0.h"
#include "queue.h"
#include "lpc177x_8x_eeprom.h"
#include "Cmd_process.h"

#include "uip.h"
#include "uip_arp.h"
#include "timer.h"
#include "icmp.h"
#include "udp_server.h"
#include "lpc17xx_emac.h"
#include "menu.h"
#include "optics_judge.h"

#include "drv595.h"
#include "ADC.h"
#include "OSW.h"
#include "rtc.h"
#include "AT24C512.h"


#define  BUF ((struct uip_eth_hdr *)&uip_buf[0])  //定义以太网头部类型的结构指针
//********************************************************************************
//************************************全局变量定义*******************************
//********************************************************************************
uint8  ver[6]= {"V1.00\0"};	                      //当前版本号，需要修改
uint8  Reset_flag=0;                              //http 网页的复位标示
uint8  password[18]= {"88888\0"};                 //登陆网页的密码
uint16 TCP_lport;                                 //TCP收发指令端口
uint8  ICMP_NUM=0;                                //发ICMP包的通道序号
uint8  NET_Bypass_flag[CHANNEL_NUM]= {1};         //网口控制切换标示:  1表示要切换到旁路 ,0表示要切换到主路
uint8  ICMP_time_en[CHANNEL_NUM]= {0};            //发ICMP数据包后的计时使能标示
uint16 ICMP_time_couter[CHANNEL_NUM]= {0};        //发ICMP数据包后的计时变量
uint8  ICMP_reply_flag[CHANNEL_NUM]= {0};         //收到ICMP,协议回显数据包标示
uint16 Lost_bag[CHANNEL_NUM]= {0};                //ICMP数据包丢包的计数变量

uint8  Runflag=0;                                 //LED 运行灯
uint8  BEE_ON_flag=1;                             //蜂鸣器 开启标示
uint8  Menu_layer=0;                              //菜单等级  (0:初始菜单  1:第一级菜单  2:第二级菜单)
uint8  KeyStyle;                                  //按键类型
uint8  Key_Enrer_flag=0;                          //按键按下的标示
uint8  Powercal_MODE=0;                           //进入按键校准模式的标示
uint8  Correct_Select=0;                          //校准选择项(0:通道, 1:波长, 2:功率)
uint8  RX_Select=0;                               //校准通道选择
uint8  Menu_Index=0;                              //主菜单的选择序列号
uint8  Trends_display=1; 		                  //定时动态更新显示任务允许标示
uint32 BLCD_TimeTicks=0;                          //LCD 背光计时变量
//uint8  LOG_PRINT_FLAG=0;                          //打印 LOG 的标志
uint16 LOG_Print_Index=0;                         //已打印的序列号

uint8  POW1,POW2;				                  //电源状态，
uint8  OSW_state[CHANNEL_NUM]= {0};               //通道选着       0 旁路     1主路
uint8  BHflag[CHANNEL_NUM];    		  		      //2分钟切换10次以上变手动的保护设置。（旁路器必须切换到旁路状态）
uint32 BH_Tick[CHANNEL_NUM];                      //保护设置 计时变量
uint32 BackOSW_Time_Tick[CHANNEL_NUM]= {0};       //回切计时变量

uint8  u0ReviceBuf[120];                          //任务TaskUart0Revice 用的数组
uint8  LOG_Buf[200];
struct EPROM_DATA  EPROM;                         //保存EPROM设置参数的结构体
struct timer  ICMP_timer[CHANNEL_NUM];            //定时发ICMP包的设置参数的结构体
struct uip_udp_conn *Send_LOG_conn;               //发LOG的 UDP 连接

OS_EVENT *Uart0ReviceMbox;                        //串口 0 接收邮箱
OS_EVENT *EMAC_Read_Sem;                          //以太网数据包读取信号量
OS_EVENT *LOG_PRINT_FLAG;                         //打印 LOG 的 信号量

OS_STK   TaskWDTStk[TASK_STK_SIZE];
OS_STK   TaskEMAC_ReadStk[TASK_STK_SIZE*3];
OS_STK   taskENETStk[TASK_STK_SIZE*2];
OS_STK   TaskCollectStk[TASK_STK_SIZE*2];
OS_STK   TaskSwitchStk[TASK_STK_SIZE];
OS_STK   TaskUart0Stk[TASK_STK_SIZE*2];
OS_STK   TaskUart0ReviceStk[TASK_STK_SIZE*2];
OS_STK   TaskShowStk[TASK_STK_SIZE*2];
OS_STK   TaskKeyStk[TASK_STK_SIZE*2];
OS_STK   SEND_LOGStk[TASK_STK_SIZE*2];

//********************************************************************************
//************************************声明任务***********************************
//********************************************************************************
void  TaskWDT(void *pdata);
void  TaskEMAC_Read(void *pdata);
void  taskENET(void  *parg);
void  TaskCollect(void *pdata);
void  TaskRT2(void *pdata);
void  TaskSwitch(void *pdata);
void  TaskUart0Cmd(void *pdata);
void  TaskUart0Revice(void *pdata);
void  TaskUart1Revice(void *pdata);
void  TaskShow(void *pdata);
void  TaskKey(void *pdata);
void  UDP_SEND_LOG(void *pdata);

/*********************************************************************************************************
** 函数名称: restore_set()
** 功能描述: 出厂默认设置
** 输　出:   无
********************************************************************************************************/
void restore_set(void)
{
    uint8 i;
    uint8 ipaddr[4];
    OS_CPU_SR  cpu_sr;

    //EPROM.MAC_addr[6];    //  MAC 地址
    EPROM.TCP_lport=0x0fa1; // 	TCP端口 4001
    uip_ipaddr(ipaddr,192,168,0,178);
    uip_ipaddr_copy(EPROM.hostaddr,ipaddr); //主机IP
    uip_ipaddr(ipaddr,192,168,0,1);
    uip_ipaddr_copy(EPROM.draddr,ipaddr);   //默认网关
    uip_ipaddr(ipaddr,255,255,255,0);
    uip_ipaddr_copy(EPROM.netmask,ipaddr);  //子网掩码

    EPROM.BPS=9;         //串口波特率(115200)
    EPROM.Language=0;    //语言: 0 中文 , 1 English
    EPROM.disnum=0;      //屏幕显示公司名选项
    EPROM.mode=1;        //机箱类型: 1表示1U，4表示4U。
    EPROM.modeldis=1;    //型号显示设置:
    EPROM.address=1;     //设备地址: 00 ~ 99。
    EPROM.POW1flag=1;    //电源1的配置: 代号：0-无；1-220VAC；2-48VDC；3-24VDC；
    EPROM.POW2flag=2;    //电源2的配置: 代号：0-无；1-220VAC；2-48VDC；3-24VDC
    EPROM.language=0;    //语言标识：0表示中文，1表示英文
    EPROM.key_admin=1;   //按键使用权限: 1表示允许使用，0表示禁止使用。
    EPROM.BEEflag=1;     //蜂鸣器开关设置: 1表示允许使用，0表示禁止使用。
    EPROM.LCDT=3;        //LCD背光：1-15秒，2-30秒，3-1分，4-2分，5-5分，6-长亮
    EPROM.Start_delay=0; //开机延时时间
    EPROM.LINK_num =4;   //链路数


    for(i=0; i<CHANNEL_NUM; i++)
    {
        EPROM.Ping_switch_en[i]=1;      	//在自动模式时,手动设置为主路后,PING检测切换使能标志
        EPROM.Autoflag[i]=1;  		  		//当前工作模式：0表示手动，1表示自动

        EPROM.q_power[i*4+0]= -30.0;        //告警功率切换点
        EPROM.q_power[i*4+1]= -30.0;        //告警功率切换点
        EPROM.q_power[i*4+2]= -30.0;        //告警功率切换点
        EPROM.q_power[i*4+3]= -30.0;        //告警功率切换点

        EPROM.wavelength[i*4+0]=0;          //波长:1-1550 , 0-1310
        EPROM.wavelength[i*4+1]=0;          //波长:1-1550 , 0-1310
        EPROM.wavelength[i*4+2]=0;          //波长:1-1550 , 0-1310
        EPROM.wavelength[i*4+3]=0;          //波长:1-1550 , 0-1310

        EPROM.Auto_Manual_delay[i]=30;   	//手动返回自动延时
        EPROM.accessflag[i]=1; 		  		//回切方式设置:
        EPROM.BackOSW_Delay[i]=0;    	  	//回切延时时间
        EPROM.OSW_Condition[i]=4;           //旁路判断的条件
        EPROM.BackOSW_Condition[i]=1;       //回切判断的条件
        EPROM.Ping_en[i]=1;     		  	//心跳控制标志  1:使能   0:禁止
        EPROM.Send_ICMP_interval[i]=5;   	//发ICMP包的间隔(10ms为单位)
        EPROM.time_out[i]=5;                //接收数据包超时设置 (10ms为单位)
        EPROM.lost_max[i]=5;				//连续丢包数旁路设置 (单位为个)
        EPROM.PROTECT[i]=1;                 //开关保护使能标示
        EPROM.SWNUM[i]=0; 	   	 			//开关切换次数

        //ping的目标IP(1~4路)
        uip_ipaddr(ipaddr,192,168,0,198+i);
        uip_ipaddr_copy(EPROM.pingaddr[i],ipaddr );
    }

    //先喂一次看门狗,防止保存过程中时间太长出现复位, 而导致保存失败
    OS_ENTER_CRITICAL();
    LPC_WDT->FEED = 0xAA;
    LPC_WDT->FEED = 0x55;
    OS_EXIT_CRITICAL();

    //再给EEPROM初始化,防止EEPROM出问题,无法保存
    LPC1778_EEPROM_Init( );

    //保存MAC 地址往后的参数到 EPROM 中
    Save_To_EPROM((uint8 *)&EPROM.TCP_lport, sizeof(struct EPROM_DATA));
    OSTimeDly(10);

    //初始化 RTC 时间
    //RTC_time_Init();
}

/*********************************************************************************************************
** 函数名称: systemInt
** 功能描述: 初始化
** 输　出:

********************************************************************************************************/
void READ_EPROM_Init(void)
{
    uint8 i;

    LPC1778_EEPROM_Init( );     //I2C 初始化
    //restore_set();
    BEE_OFF;                    //关蜂鸣器
    BLCD_ON;                    //LCD背光 开

    //**************************读取EPROM中的参数***********************
    EEPROM_Read_Str( 0x00, (uint8 *)&EPROM.MAC_addr, sizeof(struct EPROM_DATA) );
    delay_nms(20);
    //再读一次防止出现误码
    EEPROM_Read_Str( 0x00, (uint8 *)&EPROM.MAC_addr, sizeof(struct EPROM_DATA) );
    delay_nms(20);

    //******************************初始化信息**************************
    //MAC地址初始化
    for(i=0; i<6; i++)
    {
        uip_ethaddr.addr[i]=EPROM.MAC_addr[i];
    }
    TCP_lport=EPROM.TCP_lport;                     //TCP通信端口初始化
    uip_hostaddr[0] = EPROM.hostaddr[0];           //IP地址初始化
    uip_hostaddr[1] = EPROM.hostaddr[1];
    uip_netmask[0]  = EPROM.netmask[0];            //默认网关初始化
    uip_netmask[1]  = EPROM.netmask[1];
    uip_draddr[0]   = EPROM.draddr[0];             //子网掩码初始化
    uip_draddr[1]   = EPROM.draddr[1];

    //初始化N路的Ping 目标地址
    for(i=0; i<CHANNEL_NUM; i++)
    {
        uip_pingaddr[i][0] = EPROM.pingaddr[i][0];
        uip_pingaddr[i][1] = EPROM.pingaddr[i][1];
    }

    //屏幕显示
    if(EPROM.disnum<100)
    {
        EPROM.disnum=EPROM.disnum;
    }
    else
    {
        EPROM.disnum=0;
    }
    //机箱类型: 1表示1U，4表示4U。
    if(EPROM.mode==4)
    {
        EPROM.mode = 4;
    }
    else
    {
        EPROM.mode = 1;
    }
    //型号显示设置:
    if(EPROM.modeldis==0)
    {
        EPROM.modeldis=0;
    }
    else
    {
        EPROM.modeldis=1;
    }
    //设备地址: 00 ~ 99。硬件编址
    if(EPROM.address > 99)
    {
        EPROM.address = 1;
    }
    else
    {
        EPROM.address = EPROM.address ;
    }
    //电源1的配置: 代号：0-无；1-220VAC；2-48VDC；3-24VDC；
    if((EPROM.POW1flag>0 )&& (EPROM.POW1flag<=9) );
    else
    {
        EPROM.POW1flag=1;     //默认值
    }
    //电源2的配置: 代号：0-无；1-220VAC；2-48VDC；3-24VDC；
    if(EPROM.POW2flag>0 && EPROM.POW2flag<=9);
    else
    {
        EPROM.POW2flag=2;     //默认值
    }
    //语言标识：0表示中文，1表示英文。
    if(EPROM.language==1)
    {
        EPROM.language = 1;
    }
    else
    {
        EPROM.language = 0;
    }
    //按键使用权限: 1表示允许使用，0表示禁止使用。
    if(EPROM.key_admin==0)
    {
        EPROM.key_admin = 0;
    }
    else
    {
        EPROM.key_admin = 1;
    }
    //蜂鸣器开关设置: 1表示允许使用，0表示禁止使用。
    if(EPROM.BEEflag==0)
    {
        EPROM.BEEflag=0;
    }
    else
    {
        EPROM.BEEflag=1;
    }
    //LCD背光：1-15秒，2-30秒，3-1分，4-2分，5-5分，6-长亮
    if( EPROM.LCDT>=1 && EPROM.LCDT<=6 );
    else EPROM.LCDT=3;  	  //默认值
    //开机延时时间
    if( EPROM.Start_delay < 10000 ) ;
    else	EPROM.Start_delay  = 10;  //默认初始值
    //链路数
    //if( EPROM.LINK_num==2 || EPROM.LINK_num==4 )
    //    CHANNEL_NUM=EPROM.LINK_num;
    //else CHANNEL_NUM=4;


    for(i=0; i<CHANNEL_NUM; i++)
    {
        //在自动模式时,手动设置为主路后,PING检测切换使能标志
        if(EPROM.Ping_switch_en[i]==1);
        else  EPROM.Ping_switch_en[i]=0;
        //心跳控制标志
        if(EPROM.Ping_en[i]==0);
        else  EPROM.Ping_en[i]=1;
        //当前工作模式：0表示手动，1表示自动。
        if(EPROM.Autoflag[i]==1)
        {
            EPROM.Autoflag[i] = 1;
//            AUTO_LED_H;
        }
        else
        {
            EPROM.Autoflag[i] = 0;
//           AUTO_LED_L;
        }

        //回切方式设置:
        if(EPROM.accessflag[i]==0);
        else
        {
            EPROM.accessflag[i] = 1;
        }
        //回切延时
        if( EPROM.BackOSW_Delay[i] < 10000 ) ;
        else	EPROM.BackOSW_Delay[i]  = 10;//默认初始值
        //手动返回自动延时
        if( EPROM.Auto_Manual_delay[i] < 10000 );
        else	EPROM.Auto_Manual_delay[i] = 30;//默认初始值
        //接收数据包超时设置
        if( EPROM.time_out[i] < 10000 );
        else    EPROM.time_out[i]=1;
        //连续丢包数旁路设置
        if( EPROM.lost_max[i] < 10000 );
        else    EPROM.lost_max[i]=10;
        //开关保护
        if( EPROM.PROTECT[i]==0 );
        else EPROM.PROTECT[i]=1;

        EPROM.SWNUM[i]=0;
    }
}

/*******************************************************************************************************
** 函数名称: main
** 功能描述: 主函数
** 输　入: 无
** 输　出: 无
********************************************************************************************************/
int main (void)
{
    RUN_LED_PORT_INIT;
    BEE_PORT_INIT;
    LCD_PORT_INIT;
    HC595_PORT_INIT;
    AD_CHANNEL_PORT_INIT;
    SW_CON_PORT_INIT;

    SystemInit();

    IntDisAll();  // Note:由于使用UCOS, 在OS运行之前运行,注意别使能任何中断.
    OSInit();

    OS_CPU_SysTickInit(SystemCoreClock/OS_TICKS_PER_SEC);

    OSTaskCreate(TaskWDT,  (void *)0, &TaskWDTStk[TASK_STK_SIZE - 1],                1);
    OSTaskCreate(taskENET, (void *)0, &taskENETStk[TASK_STK_SIZE*2-1],               2);
    OSTaskCreate(TaskEMAC_Read,(void *)0, &TaskEMAC_ReadStk[TASK_STK_SIZE*3 - 1],    3);
    OSTaskCreate(TaskCollect,  (void *)0, &TaskCollectStk[TASK_STK_SIZE*2- 1],       4);
    OSTaskCreate(TaskSwitch,(void *)0, &TaskSwitchStk[TASK_STK_SIZE - 1],            5);
    OSTaskCreate(TaskUart0Cmd,    (void *)0, &TaskUart0Stk[TASK_STK_SIZE*2 - 1],     6);
    OSTaskCreate(TaskUart0Revice, (void *)0, &TaskUart0ReviceStk[TASK_STK_SIZE - 1], 9);
    OSTaskCreate(TaskShow, (void *)0, &TaskShowStk[TASK_STK_SIZE*2 - 1], 			 10);
    OSTaskCreate(TaskKey,  (void *)0, &TaskKeyStk[TASK_STK_SIZE*2 - 1],  			 11);
    OSTaskCreate(UDP_SEND_LOG,  (void *)0, &SEND_LOGStk[TASK_STK_SIZE*2 - 1],  		 12);


    //必须在此建立邮箱和信号量，因为在启动多任务运行后会产生中断，而导致无法建立邮箱和信号量
    //建立串口0的接收邮箱
    Uart0ReviceMbox = OSMboxCreate(NULL);
    if (Uart0ReviceMbox == NULL)
    {
        while (1);
    }

    //建立网口的中断接收信号量
    EMAC_Read_Sem = OSSemCreate(0);
    if (EMAC_Read_Sem == NULL)
    {
        while (1);
    }

    //建立网口的中断接收信号量
    LOG_PRINT_FLAG = OSSemCreate(0);
    if (LOG_PRINT_FLAG == NULL)
    {
        while (1);
    }


    OSStart ();
    return 0;
}

/*********************************************************************************************************
** 函数名称: TaskWDT
** 功能描述: 看门狗复位
** 输　入: 无
** 输　出: 无
** 说  明: 看门狗使用内部RC时钟(4MHz),经过4次分频。T=0x1000000*1us=1s (看门狗复位定时时间)
********************************************************************************************************/
void  TaskWDT(void *pdata)
{
    uint8 i;
    uint8 runTime=0;
    uint16 Reset_timetick=0;
    OS_CPU_SR  cpu_sr;

    READ_EPROM_Init();      //读EPROM初始化参数
    AT24C512_I2C_Init();    //AT24C512 初始化

    UART0Init();            //串口初始化(必须先读EPROM 中的串口配置叁数后才能初始化 )!!!!!!!!!!!!!
    LCD_Init();             //LCD 初始化
    ChannelLED( 16 ,0);	    //初始化时关闭所有的 LED


    for ( i = 0 ; i < CHANNEL_NUM; i++ )
    {
        //开机上电设置为自动模式
        EPROM.Autoflag[i]=1;
        ChannelLED(i*6, 1);

        //开机上电设置为主路
        SW_CON1_L;
        SW_CON2_H;

        SW_CON5_L;
        SW_CON6_H;
        OSW_state[i] = 1;
        ChannelLED(i*6+1, 1);       //对应通道的指示灯亮
    }

    //*******************开启看门狗********************/
    //LPC1778的看门狗使用内部RC时钟(500KHz),经过4次分频(500K/4=125K ,即十六进制为0X1E848)
    //LPC_WDT->TC  = 0X1E848;  ; //设置WDT定时值为1秒.
    //LPC_WDT->MOD = 0x03;       //设置WDT工作模式,启动WDT

    while(1)
    {
        OS_ENTER_CRITICAL();
        LPC_WDT->FEED = 0xAA;
        LPC_WDT->FEED = 0x55;
        OS_EXIT_CRITICAL();

        if(runTime++ >= 5)  //设定延时时间
        {
            runTime = 0;
            if(Runflag == 1)
            {
                RUN_LED_H;
                Runflag=0;
            }
            else if(Runflag == 0)
            {
                RUN_LED_L;
                Runflag=1;
            }
        }

        //***********************************************************************/
        //按一键恢复出厂默认值操作
        //***********************************************************************/
        if ( RESET_PIN == 0 )
        {
            OSTimeDly(20);
            if ( RESET_PIN == 0 )
            {
                do
                {
                    Reset_timetick++;

                    OS_ENTER_CRITICAL();
                    LPC_WDT->FEED = 0xAA;
                    LPC_WDT->FEED = 0x55;
                    OS_EXIT_CRITICAL();
                    OSTimeDly(10);
                }
                while( RESET_PIN == 0 );

                if(Reset_timetick >= 250)  //长按恢复出厂设置
                {
                    Reset_timetick=0;
                    restore_set();
                    Trends_display = 0;
                    if ( EPROM.Language )
                    {
                        LCD_PutStr(0,0,"   Restore Set OK   ");
                        LCD_PutStr(1,0,"                    ");
                    }
                    else
                    {
                        LCD_PutStr(0,0,"  恢复出厂设置成功  ");
                        LCD_PutStr(1,0,"                    ");
                    }
                    OSTimeDly(1000);
                    Reset_Handler();
                }
                else                       //短按 复位
                {
                    Reset_timetick=0;
                    Trends_display = 0;
                    if ( EPROM.Language )
                    {
                        LCD_PutStr(0,0,"      Reset OK      ");
                        LCD_PutStr(1,0,"                    ");
                    }
                    else
                    {
                        LCD_PutStr(0,0,"      复位成功      ");
                        LCD_PutStr(1,0,"                    ");
                    }
                    OSTimeDly(1000);
                    Reset_Handler();
                }
            }
        }

        OSTimeDly(100);
    }
}
/*********************************************************************************************************
** 函数名称: void ENET_IRQHandler (void)
** 功能描述: 中断接收网口数据
** 输　入: 无
** 输　出: 无
** 说  明:
********************************************************************************************************/
void ENET_IRQHandler(void)
{
    uint32 int_stat;
    OS_CPU_SR  cpu_sr;

    OSIntEnter();
    OS_ENTER_CRITICAL(); //禁止中断

    if ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0)
    {
        LPC_EMAC->IntClear = int_stat;
        if ((int_stat & INT_RX_DONE))
        {
            OSSemPost(EMAC_Read_Sem);
        }
    }

    OS_EXIT_CRITICAL();    //打开中断
    OSIntExit();

}

/*********************************************************************************************************
** 函数名称:
** 功能描述:
** 输　入: pdata        任务附加参数(指针)
** 输　出: 无
** 运算时间 :
********************************************************************************************************/
#define BUF  ((struct uip_eth_hdr *)&uip_buf[0])
void  TaskEMAC_Read(void *pdata)
{
    uint8 err=0;

    while(1)
    {
        OSSemPend(EMAC_Read_Sem, 0, &err);
        if( (err == 0) )
        {
            uip_len = EMAC_ReadPacket();
            if(BUF->type == htons(UIP_ETHTYPE_IP))
            {
                uip_input();
                if(uip_len > 0)
                {
                    uip_arp_out();
                    EMAC_SendPacket(uip_buf,uip_len);
                    uip_len=0;
                    //等待 WEB 发完数据后再实行复位。
                    if( Reset_flag==1 )
                    {
                        Reset_Handler();  //实行软件复位 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        Reset_flag=0;
                    }
                }
            }
            else if(BUF->type == htons(UIP_ETHTYPE_ARP))
            {
                uip_arp_arpin();
                if(uip_len > 0)
                {
                    EMAC_SendPacket(uip_buf,uip_len);
                    uip_len=0;
                }
            }
        }
    }
}

/*********************************************************************************************************
** 函数名称:  static  void  task1 (void  *parg)
** 功能描述:  UIP收发处理
** 输　入: 无
** 输　出: 无

********************************************************************************************************/
uint8 EMAC_Ini_OK=0;
void  taskENET (void  *pdata)
{
    static int i=0;
    u8_t ch_num;
    uip_ipaddr_t addr;
    struct  timer periodic_timer, arp_timer, arp_broadcast_timer;

    EMAC_Ini_OK=LPC_EMAC_Init();          //网口初始化 !!!!!!!!!!!!!!!
    /*
    TCP_lport=8000;                       //TCP通讯端口
    uip_ipaddr(ipaddr,192,168,1,225);
    uip_sethostaddr(ipaddr);
    uip_ipaddr(ipaddr,192,168,1,1);
    uip_setdraddr(ipaddr);
    uip_ipaddr(ipaddr,255,255,255,0);
    uip_setnetmask(ipaddr);

    uip_ipaddr(ipaddr,192,168,1,111);
    uip_setpingaddr( 0,ipaddr );
    uip_ipaddr(ipaddr,192,168,1,112);
    uip_setpingaddr( 1,ipaddr );
    uip_ipaddr(ipaddr,192,168,1,113);
    uip_setpingaddr( 2,ipaddr );
    uip_ipaddr(ipaddr,192,168,1,114);
    uip_setpingaddr( 3,ipaddr );
     */
    uip_init();
    uip_arp_init();
    tcp_server_init();
    udp_server_init();
    /*
        uip_ipaddr(&addr, 192,168,0,126);
        Send_LOG_conn = uip_udp_new(&addr, HTONS(12345));
        if(Send_LOG_conn != NULL)
        {
            uip_udp_bind(Send_LOG_conn, HTONS(12366));
        }
    */

    //设置TCP 超时处理时间和ARP 老化时间
    timer_set(&periodic_timer, 500);          //500ms
    timer_set(&arp_timer,    10000);          //10s
    timer_set(&arp_broadcast_timer, 2000);    //2s
    for(i=0; i<CHANNEL_NUM; i++)
    {
        //心跳间隔设置(10毫秒为单位)
        timer_set(&ICMP_timer[i], EPROM.Send_ICMP_interval[i]*10 ); ///CHANNEL_NUM
        //timer_set(&ICMP_timer[i], 10 ); ///CHANNEL_NUM
    }

    while (1)
    {
        //查看0.5S 是否到了，到了则调用uip_periodic 处理TCP
        if(timer_expired(&periodic_timer))
        {
            timer_reset(&periodic_timer);
            for(i = 0; i < UIP_CONNS; i++)      //UIP_CONNS=10
            {
                uip_periodic(i);
                if(uip_len > 0)
                {
                    uip_arp_out();
                    EMAC_SendPacket(uip_buf,uip_len);
                }
            }

#if UIP_UDP
            for(i = 0; i < UIP_UDP_CONNS; i++)  //UIP_UDP_CONNS=10
            {
                uip_udp_periodic(i);
                if(uip_len > 0)
                {
                    uip_arp_out();
                    EMAC_SendPacket(uip_buf,uip_len);
                }
            }
#endif // UIP_UDP 

            if(timer_expired(&arp_timer))        //查看 10S 是否到了，到了则调用ARP处理程序
            {
                timer_reset(&arp_timer);
                uip_arp_timer();                 //清除老旧的IP作用
            }
        }

        //*************************************************************************/
        //----------------------间隔2s发一个广播的arp请求包---------------------
        //*************************************************************************/
        if(timer_expired(&arp_broadcast_timer))
        {
            timer_reset(&arp_broadcast_timer);
            if ( NET_LINK == 0 )
            {
                uip_arp_broadcast();           				//发出arp包
                EMAC_SendPacket(uip_buf,uip_len);
                uip_len=0;
            }
        }

        //*************************************************************************/
        // 定时发ICMP协议包 ,循坏设置4路的ICMP协议包
        //*************************************************************************/
        if( ICMP_NUM++ >= (CHANNEL_NUM-1) )
        {
            ICMP_NUM=0;
        }
        if( timer_expired(&ICMP_timer[ICMP_NUM]) )
        {
            timer_reset(&ICMP_timer[ICMP_NUM]);         //清零计时参数
            if( (EPROM.Ping_en[ICMP_NUM]==1) )
            {
                if ( NET_LINK == 0 )
                {
                    ICMP_set(ICMP_NUM);
                    EMAC_SendPacket(ICMP_buf,uip_len);
                    uip_len=0;
                }
                ICMP_time_en[ICMP_NUM]=1;               //当ICMP_time_en=1 时启动计数
            }
        }

        //*************************************************************************/
        //循环判断接收ICMP协议回显和判断超时处理(CHANNEL_NUM 为路数)
        //*************************************************************************/
        for( ch_num=0; ch_num<CHANNEL_NUM; ch_num++ )
        {
            //判断收到ICMP,协议回显数据包标示且发Ping包使能
            if( ICMP_reply_flag[ch_num]==1 && EPROM.Ping_en[ch_num]==1 )
            {
                ICMP_reply_flag[ch_num]=0;              //回显数据包标示置零
                ICMP_time_en[ch_num]=0;                 //停止计时，
                ICMP_time_couter[ch_num]=0;		        //清零计时变量
                Lost_bag[ch_num]=0;						//丢包计数变量清零
                NET_Bypass_flag[ch_num]=0;				//开关切换标示置0,表示要切换到主路
            }
            //判断是否超时，且发ping包使能开启
            else if( ICMP_time_couter[ch_num] >= EPROM.time_out[ch_num] && EPROM.Ping_en[ch_num]==1 )
            {
                ICMP_time_en[ch_num]=0;                 //停止计时，
                ICMP_time_couter[ch_num]=0;				//清零计时变量
                Lost_bag[ch_num]++;    				    //增加丢包计数变量
            }
            //丢包的数量大于限定值
            if( Lost_bag[ch_num] > EPROM.lost_max[ch_num] )
            {
                Lost_bag[ch_num]=0;                     //丢包计数变量清零
                NET_Bypass_flag[ch_num]=1;              //开关切换标示置1,表示要切换到旁路
            }
        }

        OSTimeDly(2);
    }
}
/*********************************************************************************************************
** 函数名称: TaskCollect
** 功能描述: R1、R2通道功率采集
** 输　入:   pdata 任务附加参数(指针)
** 输　出: 无
** 运算时间 :
********************************************************************************************************/
void  TaskCollect(void *pdata)
{
    uint8 i;

    OSTimeDly(20);

    ADC_int(400);           //ADC初始化

    //初始化模拟开关位置
    for ( i = 0 ; i < CHANNEL_NUM ; i++ )
    {
        hardware_way[i] = 4;
        CHANNEL(i,4);       //设定到1通道
    }

    while(1)
    {
        optics_collect( 0,  hardware_way[0] );  //采集第 1 通道的光功率
        optics_collect( 1 , hardware_way[1] );  //采集第 2 通道的光功率
        optics_collect( 2 , hardware_way[2] );  //采集第 3 通道的光功率
        optics_collect( 3 , hardware_way[3] );  //采集第 4 通道的光功率
        OSTimeDly(2);

        optics_collect( 4,  hardware_way[4] );  //采集第 5 通道的光功率
        optics_collect( 5 , hardware_way[5] );  //采集第 6 通道的光功率
        optics_collect( 6 , hardware_way[6] );  //采集第 7 通道的光功率
        optics_collect( 7 , hardware_way[7] );  //采集第 8 通道的光功率
        OSTimeDly(2);
    }
}

/*********************************************************************************************************
** 函数名称: TaskSwitch
** 功能描述: 告警
** 输　入: pdata        任务附加参数(指针)
** 输　出: 无
** 运算时间 :
********************************************************************************************************/
void  TaskSwitch(void *pdata)
{
    uint8 i;
    uint8 Bypass_num=0;             //记录旁路的链路数，在蜂鸣器告警中用到
    uint8 Alarm_flag=0;             //告警类型

    OSTimeDly(2000+EPROM.Start_delay*1000);   //开机延时

    while(1)
    {
        optics_judge(0, 0 ,1, 2 ,3 );//第一条链路把第 0,1,2,3 通道的光功率判断比较
        optics_judge(1, 4 ,5, 6 ,7 );//第二条链路把第 4,5,6,7 通道的光功率判断比较

        Bypass_num = 0;
        for ( i = 0 ; i <CHANNEL_NUM ; i++ )
        {
            if( EPROM.Autoflag[i]== 1)
            {
                //*****************则由光控 和 PING心跳 控制的 Bypass 设备***********************
                if( (Optics_Bypass_flag[i]==0) && (NET_Bypass_flag[i]==0) )
                {
                    if(EPROM.accessflag[i]==1)
                    {
                        if((EPROM.BackOSW_Delay[i] >= 0) && (BackOSW_Time_Tick[i] == 0))
                        {
                            BackOSW_Time_Tick[i] = 1;    //启动计时
                        }
                    }
                }
                else
                {
                    BackOSW_Time_Tick[i] = 0;	 //屏蔽 回切延时
                    if ( OSW_state[i] != 0  )
                    {
                        BypassSwitch(i);
                        //********************判断蜂鸣器的告警类型******************************
                        Bypass_num++;                //记录旁路的链路数
                        if(Bypass_num == 1)         Alarm_flag = 1;
                        else if(Bypass_num >= 2)    Alarm_flag = 2;
                        BEE_ON_flag=1;
                    }
                }
                //回切延时时间到, 实行回切动作
                if(BackOSW_Time_Tick[i] >= (EPROM.BackOSW_Delay[i] *1000 + 1) )
                {
                    BackOSW_Time_Tick[i] =0;     //清零且停止计时
                    if ( OSW_state[i] != 1  )   MostSwitch(i);
                    Alarm_flag=0;
                    BEE_ON_flag =0;
                    Bypass_num--;                //记录旁路的链路数
                }

                //******************自动模式下，两分钟以内切换10次以上变为手动*****************
                if( EPROM.PROTECT[i]==1 )
                {
                    if(BH_Tick[i] == 0)
                    {
                        BH_Tick[i] = 1;         //启动计时
                    }
                    else if( (EPROM.SWNUM[i]>10) && (BH_Tick[i] <= 120001) )
                    {
                        BH_Tick[i] = 0;         //清零且停止计时
                        EPROM.SWNUM[i]=0;       //清零切换次数

                        if(OSW_state[i]==1)
                        {
                            BypassSwitch(i);    //旁路器才需要
                        }
                        //进入手动模式
                        EPROM.Autoflag[i]=0;
                        Save_To_EPROM((uint8 *)&EPROM.Autoflag[i], 1);
                    }
                    else if(BH_Tick[i] > 120001)
                    {
                        BH_Tick[i] = 0;         //清零且停止计时
                        EPROM.SWNUM[i]=0;       //清零切换次数
                    }
                }
            }
        }

        //*****************************蜂鸣器告警***************************************
        if( EPROM.BEEflag == 1 )
        {
            if(Alarm_flag== 2 && BEE_ON_flag ==1 )
            {
                BEE_ON;                             //蜂鸣器长响
            }
            else if(Alarm_flag== 1 && BEE_ON_flag ==1 )
            {
                if(Runflag == 1)        BEE_ON;
                else if(Runflag == 0)   BEE_OFF;    //蜂鸣器间隔0.5秒的响
            }
            else
            {
                BEE_OFF;
            }

            Bypass_num=0;
        }
        else  BEE_OFF;

        OSTimeDly(2); //本任务的执行间隔时间是2ms.
    }
}

/*******************************************************************************************************
**                            TaskUart0Cmd 任务0

********************************************************************************************************/
void TaskUart0Cmd (void* pdata)
{
    uint8 err;
    uint16 len;
    OS_CPU_SR  cpu_sr;

    OSTimeDly(500);            //等待延时

    //-------------------
    OS_ENTER_CRITICAL();
    UART0Write_Str("<BP");
    UART0Putch(EPROM.address/10%10+'0');
    UART0Putch(EPROM.address%10+'0');
    UART0Write_Str("_RESET_OK>");
    OS_EXIT_CRITICAL();
    //-------------------

    while(1)
    {
        (uint8 *)OSMboxPend(Uart0ReviceMbox, 0, &err);         // 等待接收邮箱数据

        if( (len = Cmd_process( (char*)&u0ReviceBuf ) ) > 0 )
        {
            UART0Put_str( u0ReviceBuf ,len );
        }
    }
}

/*********************************************************************************************************
** 函数名称: TaskUart0Revice
** 功能描述: μCOS-II的任务。从UART0接收数据，当接收完一帧数据后通过消
**           息邮箱传送到TaskStart任务。
** 输　入: pdata        任务附加参数(指针)
** 输　出: 无
********************************************************************************************************/
void  TaskUart0Revice(void* pdata)
{
    uint8 *cp;
    uint8 i,temp;

    while(1)
    {
        cp = u0ReviceBuf;
        while((*cp = UART0Getch()) !='<' ) ;        // 接收数据头
        cp++;   								    //往下移一个字节
        for (i = 0; i < 50; i++)
        {
            temp = UART0Getch();
            *cp++ = temp;
            if (temp =='>')
            {
                while(i < 48)
                {
                    *cp++ = 0;                      //空余的后面补0
                    i++;
                }
                break;
            }
        }

        OSMboxAccept(Uart0ReviceMbox);              //清空 邮箱Uart0ReviceMbox
        OSMboxPost(Uart0ReviceMbox, (void *)u0ReviceBuf);
    }
}

/*********************************************************************************************************
** 函数名称: TaskShow
** 功能描述: LCD 显示
** 输　入: pdata        任务附加参数(指针)
** 输　出: 无
********************************************************************************************************/
void  TaskShow(void *pdata)
{
    uint8  i;
    uint8  wave_temp;
    uint8  LCD_dispbuf[20];
    uint16 temp16;
    RTCTime local_time;

    OSTimeDly(500);                //开机延时一会再显示
    //LCD_PutStr(0,0,"       SEG-OLP      ");
    //LCD_PutStr(1,0,"                    ");
    //OSTimeDly(2000);

    RTCInit();
    RTCStart();

    while(1)
    {

        local_time = RTCGetTime( );

        if(Trends_display == 1)
        {
            if(Powercal_MODE == 1)       //功率校准
            {
                LCD_WriteCmd(0x0d); //画面显示开,光标显示关,反白显示开

                //显示 "1R1:-50.00dBm 1310nm"
                LCD_dispbuf[0]=(RX_Select)/4+'1';
                LCD_dispbuf[1]='R';
                LCD_dispbuf[2]=(RX_Select)%4+'1';
                LCD_dispbuf[3]=':';
                if(power[RX_Select] >= 0)
                {
                    LCD_dispbuf[4] = ' ';
                    temp16 =  power[RX_Select]*100;
                }
                else
                {
                    LCD_dispbuf[4] = '-';
                    temp16 = (0 - power[RX_Select])*100;
                }
                LCD_dispbuf[5] = temp16/1000+'0';
                LCD_dispbuf[6] = temp16%1000/100+'0';
                LCD_dispbuf[7] = '.';
                LCD_dispbuf[8] = temp16%100/10+'0';
                LCD_dispbuf[9] = temp16%10+'0';
                LCD_dispbuf[10] = 0;
                LCD_PutStr(0,0,LCD_dispbuf);
                LCD_PutStr(0,5,"dBm ");

                if(EPROM.wavelength[RX_Select] == 0)
                    LCD_PutStr(0,7,"850nm ");
                else LCD_PutStr(0,7,"1550nm");

                if(EPROM.wavelength[RX_Select] == 0)
                    LCD_PutStr(0,7,"850nm ");
                else LCD_PutStr(0,7,"1550nm");

                //显示 "校准补偿:  +00.00dBm  "
                LCD_PutStr(1,0,"校准补偿: ");

                wave_temp = EPROM.wavelength[RX_Select];
                if(EPROM.ADC_just[RX_Select][wave_temp] >= 0)
                {
                    LCD_dispbuf[0] = '+';
                    temp16 = EPROM.ADC_just[RX_Select][wave_temp]*10;
                }
                else
                {
                    LCD_dispbuf[0] = '-';
                    temp16 = (~ (EPROM.ADC_just[RX_Select][wave_temp]-1) )*10;
                }
                LCD_dispbuf[1] = '0';
                LCD_dispbuf[2] = temp16%1000/100+'0';
                LCD_dispbuf[3] = '.';
                LCD_dispbuf[4] = temp16%100/10+'0';
                LCD_dispbuf[5] = temp16%10+'0';
                LCD_dispbuf[6] = 0;
                LCD_PutStr(1,5,LCD_dispbuf);
                LCD_PutStr(1,8,"dBm ");
                if( Correct_Select==0 )         LCD_SetCursor(0,0);
                else if( Correct_Select==1 )    LCD_SetCursor(0,8);
                else                    LCD_SetCursor(1,7);
            }
            else
            {
                LCD_WriteCmd(0x0c);//画面显示开,光标显示关,反白显示关

                //以下实现按键选择滚动显示效果
                for( i=0; i<2; i++ )
                {
                    if( (Menu_Index+i) <= 7 )
                    {
                        LCD_dispbuf[0]=(Menu_Index+i)/4+'1';
                        LCD_dispbuf[1]='R';
                        LCD_dispbuf[2]=(Menu_Index+i)%4+'1';
                        LCD_dispbuf[3]=':';
                        if(power[Menu_Index+i] >= 0)
                        {
                            LCD_dispbuf[4] = '+';
                            temp16 =  power[Menu_Index+i]*100;
                        }
                        else
                        {
                            LCD_dispbuf[4] = '-';
                            temp16 = (0 - power[Menu_Index+i])*100;
                        }
                        LCD_dispbuf[5] = temp16/1000+'0';
                        LCD_dispbuf[6] = temp16%1000/100+'0';
                        LCD_dispbuf[7] = '.';
                        LCD_dispbuf[8] = temp16%100/10+'0';
                        LCD_dispbuf[9] = temp16%10+'0';
                        LCD_dispbuf[10] = 0;
                        LCD_PutStr(i ,0,LCD_dispbuf);
                        LCD_PutStr(i,5,"dBm ");

                        if(EPROM.wavelength[Menu_Index+i] == 0)
                            LCD_PutStr(i,7,"850nm ");
                        else LCD_PutStr(i,7,"1550nm");
                    }
                    else if((Menu_Index+i) == 8 )
                    {
                        if ( EPROM.Language )
                            sprintf((char *)(&LCD_dispbuf),"Command Address:%02u",EPROM.address);
                        else
                            sprintf((char *)(&LCD_dispbuf),"设备指令地址:%02u",EPROM.address);
                    }
                    else if((Menu_Index+i) == 9 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"IP:%u.%u.%u.%u",
                                htons(uip_hostaddr[0]) >> 8,
                                htons(uip_hostaddr[0]) & 0xff,
                                htons(uip_hostaddr[1]) >> 8,
                                htons(uip_hostaddr[1]) & 0xff);
                    }
                    else if((Menu_Index+i) ==10 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"GW:%u.%u.%u.%u",
                                htons(uip_draddr[0]) >> 8,
                                htons(uip_draddr[0]) & 0xff,
                                htons(uip_draddr[1]) >> 8,
                                htons(uip_draddr[1]) & 0xff);
                    }
                    else if((Menu_Index+i) ==11 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"SM:%u.%u.%u.%u",
                                htons(uip_netmask[0]) >> 8,
                                htons(uip_netmask[0]) & 0xff,
                                htons(uip_netmask[1]) >> 8,
                                htons(uip_netmask[1]) & 0xff);
                    }
                    else if((Menu_Index+i) == 12 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"PIP1:%u.%u.%u.%u",
                                htons(uip_pingaddr[0][0]) >> 8,
                                htons(uip_pingaddr[0][0]) & 0xff,
                                htons(uip_pingaddr[0][1]) >> 8,
                                htons(uip_pingaddr[0][1]) & 0xff);
                    }
                    else if((Menu_Index+i) == 13 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"PIP2:%u.%u.%u.%u",
                                htons(uip_pingaddr[1][0]) >> 8,
                                htons(uip_pingaddr[1][0]) & 0xff,
                                htons(uip_pingaddr[1][1]) >> 8,
                                htons(uip_pingaddr[1][1]) & 0xff);
                    }
                    else if((Menu_Index+i) == 14 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"MAC%02X-%02X-%02X-%02X-%02X-%02X",
                                EPROM.MAC_addr[0],
                                EPROM.MAC_addr[1],
                                EPROM.MAC_addr[2],
                                EPROM.MAC_addr[3],
                                EPROM.MAC_addr[4],
                                EPROM.MAC_addr[5] );
                    }
                    else if( (Menu_Index+i) == 15 )
                    {
                        if ( EPROM.Language )
                            sprintf((char *)(&LCD_dispbuf),"Device ID:C040800003");
                        else
                            sprintf((char *)(&LCD_dispbuf),"设备编码:C040800003");
                    }
                    else if( (Menu_Index+i) == 16 )
                    {
                        sprintf((char *)(&LCD_dispbuf),"%4u/%02u/%02u %02u:%02u:%02u",\
                                local_time.RTC_Year,local_time.RTC_Mon,local_time.RTC_Yday,\
                                local_time.RTC_Hour,local_time.RTC_Min,local_time.RTC_Sec);
                    }
                    else if( (Menu_Index+i) == (MENU_NUM+1) )
                    {
                        LCD_PutStr(1,0,"                    ");
                    }

                    if( (Menu_Index+i) >= 8 && (Menu_Index+i)<= MENU_NUM )   LCD_Putline(i ,0,LCD_dispbuf);
                }
            }
        }
        //******************************************************************************/
        //******************************LCD背光的延时**********************************/
        //******************************************************************************/
        switch ( EPROM.LCDT )
        {
        case 1 :
            //LCD背光15秒的延时
            if ( BLCD_TimeTicks >=  (OS_TICKS_PER_SEC*15) )  //OS_TICKS_PER_SEC = 1000
            {
                BLCD_OFF;
                BLCD_TimeTicks=0;  //清零停止计时
                Goto_mian_menu();
            }
            break;
        case 2 :
            //LCD背光30秒的延时
            if ( BLCD_TimeTicks >=  (OS_TICKS_PER_SEC*30) )
            {
                BLCD_OFF;
                BLCD_TimeTicks=0;  //清零停止计时
                Goto_mian_menu();
            }
            break;
        case 3 :
            //LCD背光1分钟的延时
            if ( BLCD_TimeTicks >=  (OS_TICKS_PER_SEC*60) )
            {
                BLCD_OFF;
                BLCD_TimeTicks=0;  //清零停止计时
                Goto_mian_menu();
            }
            break;
        case 4 :
            //LCD背光2分钟的延时
            if ( BLCD_TimeTicks >=  (OS_TICKS_PER_SEC*120) )
            {
                BLCD_OFF;
                BLCD_TimeTicks=0;  //清零停止计时
                Goto_mian_menu();
            }
            break;
        case 5 :
            //LCD背光5分钟的延时
            if ( BLCD_TimeTicks >=  (OS_TICKS_PER_SEC*300) )
            {
                BLCD_OFF;
                BLCD_TimeTicks=0;  //清零停止计时
                Goto_mian_menu();
            }
            break;
        case 6 :
            //LCD背光长亮
            BLCD_ON;
            BLCD_TimeTicks=0;  //清零停止计时
            break;

        default:
            break;
        }

        OSTimeDly(500);
    }
}
/*********************************************************************************************************
** 函数名称: TaskKey
** 功能描述: 按键处理
** 输　入: pdata        任务附加参数(指针)
** 输　出: 无

********************************************************************************************************/
void TaskKey(void *pdata)
{
    uint8 wave_temp;
    uint8 Key_time;

    while(1)
    {
        if(KEY_PORT != 0x07)
        {
            OSTimeDly(10);
            if(KEY_PORT != 0x07)
            {
                Key_time=0;
                BEE_OFF;     	    //关蜂鸣器
                BEE_ON_flag=0;      //单次关闭蜂鸣器

                BLCD_ON;
                BLCD_TimeTicks = 1; //启动LCD背光计时变量计时

                do
                {
                    OSTimeDly(10);
                    Key_time++;

                    if(KEY_PORT==0x03 )    //上
                    {
                        if(Key_time>30)
                        {
                            KeyStyle=Up_Long; //长按上键
                            break;
                        }
                        else
                        {
                            KeyStyle=Up;      //短按上键
                        }
                    }
                    else if(KEY_PORT==0x06 )//下
                    {
                        if(Key_time>100)
                        {
                            KeyStyle=Dwon_Long_long; //超长按下键（查看程序版本号）
                            break;
                        }
                        else if(Key_time>30)
                        {
                            KeyStyle=Dwon_Long;//长按下键
                        }
                        else
                        {
                            KeyStyle=Dwon;     //短按下键
                        }
                    }
                    else if(KEY_PORT==0x05 )
                    {
                        if(Key_time>30)
                        {
                            KeyStyle=Enter_Long;//长按 Enter 按键
                            break;
                        }
                        else
                        {
                            KeyStyle=Enter;     //短按 Enter 按键
                        }
                    }
                    else if(KEY_PORT==0x02 )
                    {
                        if(Key_time>100)
                        {
                            KeyStyle=Up_And_Dwon;//长按时上 + 下键
                            break;
                        }
                    }
                }
                while(KEY_PORT != 0x07) ;


                if( Menu_layer==0 )                //初始菜单
                {
                    if(Powercal_MODE==0)
                    {
                        if(EPROM.key_admin==0)        //键盘锁定提示
                        {
                            Trends_display=0;
                            LCD_PutStr(0,0,"                     ");
                            if ( EPROM.Language )
                            {
                                LCD_PutStr(1,0,"      Key Lock       ");
                            }
                            else
                            {
                                LCD_PutStr(1,0,"      键盘锁定      ");
                            }
                            OSTimeDly(1500);
                            Trends_display=1;
                            Menu_layer=0;
                        }
                        else
                        {
                            if(KeyStyle == Up)
                            {
                                if(Menu_Index >0)	    Menu_Index--;
                                else          		    Menu_Index = MENU_NUM;
                            }
                            else if(KeyStyle == Dwon)
                            {
                                if(Menu_Index < MENU_NUM)	Menu_Index++;
                                else				        Menu_Index =0;
                            }
                            else if(KeyStyle == Enter_Long)
                            {
                                Menu_layer=1;
                                KeyStyle=Enter;       //再把按键类型转成 Enter，才能进入一级菜单 !!!!!!!!
                                Trends_display=0;
                            }
                            else if(KeyStyle == Up_And_Dwon)
                            {
                                Powercal_MODE=1;
                            }
                            else if(KeyStyle == Dwon_Long_long)
                            {
                                //显示设备型号和版本
                                Trends_display=0;
                                if ( EPROM.Language )
                                {
                                    LCD_PutStr(0,0,"DeviceModel:SEG-OLP ");
                                }
                                else
                                {
                                    LCD_PutStr(0,0,"设备型号: SEG-OLP   ");
                                }
                                LCD_PutStr(1,0,"                    ");
                                LCD_PutStr(1,3,ver);
                                OSTimeDly(2000);
                                Trends_display=1;
                            }
                        }
                    }
                    //----------------------------------------------
                    else if(Powercal_MODE==1)//功率校准
                    {
                        if(KeyStyle == Up)
                        {
                            if(Correct_Select==0)
                            {
                                RX_Select--;
                                if ( RX_Select == 0XFF )
                                {
                                    RX_Select= CHANNEL_NUM*4-1;
                                }
                            }
                            else if(Correct_Select==1)
                            {
                                EPROM.wavelength[RX_Select] = !EPROM.wavelength[RX_Select];
                            }
                            else if(Correct_Select==2)
                            {
                                wave_temp = EPROM.wavelength[RX_Select];
                                if(EPROM.ADC_just[RX_Select][wave_temp]< 99)
                                {
                                    EPROM.ADC_just[RX_Select][wave_temp]++;
                                }
                            }
                        }
                        else if(KeyStyle == Dwon)
                        {
                            if(Correct_Select==0)
                            {
                                RX_Select++;
                                if ( RX_Select > CHANNEL_NUM*4-1 )
                                {
                                    RX_Select=0;
                                }
                            }
                            else if(Correct_Select==1)
                            {
                                EPROM.wavelength[RX_Select] = !EPROM.wavelength[RX_Select];
                            }
                            else if(Correct_Select==2)
                            {
                                wave_temp = EPROM.wavelength[RX_Select];
                                if(EPROM.ADC_just[RX_Select][wave_temp]> (-99))
                                {
                                    EPROM.ADC_just[RX_Select][wave_temp]--;
                                }
                            }
                        }
                        else if(KeyStyle == Enter)
                        {
                            Correct_Select++;
                            if( Correct_Select>=3 ) Correct_Select=0;
                        }
                        else if(KeyStyle == Enter_Long)
                        {
                            Trends_display=0;
                            Save_To_EPROM((uint8 *)&EPROM.ADC_just, 16);   //保存到 EEPROM 中
                            show_Set_ok();
                            //LCD_PutStr(0,0,"                    ");
                            //LCD_PutStr(1,0,"      设置成功     ");
                            //OSTimeDly(1500);
                            Trends_display=1;
                        }
                        else if(KeyStyle == Up_And_Dwon)
                        {
                            Powercal_MODE=0;
                        }
                    }
                }

                if( Menu_layer==1 )
                {
                    KeyCodeAction (KeyStyle);
                }

                while(KEY_PORT != 0x07)     //等待按键放开
                {
                    OSTimeDly(2);
                }

                KeyStyle=0;                 //清零按键标志 !!!!!!!!!!!!!!!!!!!!!!!!
            }
        }
        OSTimeDly(2);
    }
}


uint16 Print_LOG( uint8* data, uint16 num )
{
    uint16 sprintf_len;

//     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
//
//     Read_AT24C512(num, (uint8 *)&SYS_LOG, sizeof(struct LOG));
//     sprintf_len = sprintf((char *)data,"%03u.%4u/%02u/%02u %02u:%02u:%02u Link%1u %s %s\r\n",\
//                            num+1,SYS_LOG.Year, SYS_LOG.Mon, SYS_LOG.Yday, SYS_LOG.Hour, SYS_LOG.Min, SYS_LOG.Sec,\
//                            SYS_LOG.Link, P_Stade[SYS_LOG.State], P_Mode[SYS_LOG.Mode] );
    return   sprintf_len;
}

/*****************************************************************************
**函 数 名: UDP_SEND_LOG
**功能描述:
**输入参数: void *pdata
**输出参数: 无
**返 回 值: 无
*****************************************************************************/
void UDP_SEND_LOG(void *pdata)
{
    uint8  err;
    uint16 i=0;
    uint16 num=0;
    

    while(1)
    {
        OSSemPend(LOG_PRINT_FLAG, 0, &err);
        
        if( (err == 0) )   
        {
        num=EPROM.AT24C512_NUM/20;
        if( EPROM.AT24C512_NUM%20 > 0) num+=1;

        for ( i = 0; i < num ; i++ )
        {
            //发送队列缓存中的串口数据
            uip_conn = Current_connr;
            uip_process(UIP_POLL_REQUEST);
            if(uip_len > 0)
            {
                uip_arp_out();
                EMAC_SendPacket(uip_buf, uip_len);
            }

            //接着再发一个确认包
            uip_conn = Current_connr;
            uip_process(Send_TCP_ACK);
            if(uip_len > 0)
            {
                uip_arp_out();
                EMAC_SendPacket(uip_buf, uip_len);
            }
            OSTimeDly(1);
        }

        LOG_PRINT_FLAG = 0;
        LOG_Print_Index = 0;
        }
        
        OSTimeDly(100);
    }
}
/*********************************************************************************************************
**                            End Of File
********************************************************************************************************/
